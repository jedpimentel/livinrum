
<!DOCTYPE html> 
<html>
  <head>
      <title>LIVINRUM</title>
      <script src="https://aframe.io/releases/0.9.2/aframe.min.js"></script>
  </head>
  <body style="font-family:courier; color:white; background-color: black">

    <section id="main"></section>
    <a-scene ar id="scene">

      <!-- <a-entity position="8.2 0 4.9" rotation="0 48 0"> -->
      <a-entity>
        <a-camera look-controls="pointerLockEnabled: false" wasd-controls></a-camera>
        <!-- <a-camera look-controls="pointerLockEnabled: true" wasd-controls></a-camera> -->
        <a-entity cursor="rayOrigin: mouse" raycaster="objects:.clickable"></a-entity>
      </a-entity>

      <a-image src="livinrum.jpg" position="0 0 -1000" height="1609.34" width="1609.34"></a-image>

      <a-entity id="blob" position='5 0 10' rotation="0 -90 0"></a-entity>
    </a-scene>
  </body>

  <script type="text/javascript">{

  // make a floor and a wall
  {

    const BLOB = document.querySelector('#blob');
    const YROOF = 8;
    const TICK_DROP_METERS = 0.005
    class Sphere {
      constructor(config={}) {
        this.element = document.createElement(config.element || 'a-sphere')
        this.element.setAttribute('color', config.color || 'white');
        this.element.setAttribute('radius', '0.01');
        this.element.setAttribute('material', "shader: flat")
        this.element.setAttribute('type', "point")

        this.element.setAttribute('position', `${config.pos_x} ${config.pos_y} ${config.pos_z}`);
        BLOB.appendChild(this.element)
      }
    }

    const dropRadius = 0.1;
    const heightSlack = 0 + dropRadius;
    AFRAME.registerComponent('drop', {
      init: function() {
          this.pos = this.el.object3D.position;
      },
      tick: function() {
          if(this.pos.y < 0-heightSlack) {
              this.el.object3D.position.y += YROOF;
          } else {
              this.el.object3D.position.y -= TICK_DROP_METERS;
          }
      }
    });


    let grass_rgb_hex_generator = () => {
      let r = Math.floor(Math.random()*(256/4)).toString(16);
      let g = Math.floor(Math.random()*(256/2) + 256/4).toString(16);
      let b = Math.floor(Math.random()*(256/4)).toString(16);
      let rgb = [r, g, b].map(i => i.length === 1 ? '0'.concat(i) : i).join("");
      return rgb;
    }
    let drop_rgb_hex_generator = () => {
      // let r = Math.floor(Math.random()*(256*1/16) + 256*15/16).toString(16);
      // let g = Math.floor(Math.random()*(256*4/16) + 256*8/16).toString(16);
      // let b = Math.floor(Math.random()*(256/16)+ 256/16).toString(16);

      let r = Math.floor(Math.random()*(256*2/8) + 256*5/8).toString(16);
      // let g = Math.floor(Math.random()*(256/8) + 256*6/8).toString(16);
      let g = r;
      let b = Math.floor(Math.random()*(256/8) + 256*7/8).toString(16);
      let rgb = [r, g, b].map(i => i.length === 1 ? '0'.concat(i) : i).join("");
      return rgb;
    }
    let cloud_rgb_hex_generator = () => {
      let r = Math.floor(Math.random()*(256*2/8) + 256*5/8).toString(16);
      // let g = Math.floor(Math.random()*(256/8) + 256*6/8).toString(16);
      let g = r;
      let b = Math.floor(Math.random()*(256/8) + 256*7/8).toString(16);
      let rgb = [r, g, b].map(i => i.length === 1 ? '0'.concat(i) : i).join("");
      return rgb;
    }
    class Dropject {
      constructor(config={}) {
        this.element = document.createElement(config.element || 'a-sphere')
        this.element.setAttribute('color', config.color || `#${drop_rgb_hex_generator()}`);
        this.element.setAttribute('opacity', '0.5')
        this.element.setAttribute('radius', dropRadius*(0.8 +0.4*Math.random()));
        this.element.setAttribute('material', "shader: flat")
        this.element.setAttribute('type', "point")

        this.element.setAttribute('drop', "point")

        this.element.setAttribute('position', `${config.pos_x} ${config.pos_y} ${config.pos_z}`);
        BLOB.appendChild(this.element)
      }
    }
    class Cloud {
      constructor(config={}) {
        this.element = document.createElement(config.element || 'a-sphere')
        this.element.setAttribute('color', config.color || `#${cloud_rgb_hex_generator()}`);
        this.element.setAttribute('radius', 1 + Math.random()*0.4);
        // this.element.setAttribute('opacity', '0.8');

        this.element.setAttribute('material', "shader: flat")
        this.element.setAttribute('type', "point")
        this.element.setAttribute('position', `${config.pos_x} ${config.pos_y} ${config.pos_z}`);
        BLOB.appendChild(this.element)
      }
    }
    class Plane {
      constructor(config={}) {
        this.element = document.createElement(config.element || 'a-plane')
        this.element.setAttribute('color', config.color || `#${grass_rgb_hex_generator()}`);
        this.element.setAttribute('rotation', '-90 0 0');
        this.element.setAttribute('material', "shader: flat")
        this.element.setAttribute('type', "point")

        this.element.setAttribute('position', `${config.pos_x} ${config.pos_y} ${config.pos_z}`);
        BLOB.appendChild(this.element)
      }
    }
    // class Marker extends Sphere {
    //   // this is just a convenience thing
    //   constructor(x, y, z) {
    //     super({pos_x:x, pos_y:y, pos_z:z})
    //   }
    // }
    class Marker extends Dropject {
      // this is just a convenience thing
      constructor(x, y, z) {
        super({pos_x:x, pos_y:y, pos_z:z})
      }
    }
    class CloudWithPosThing extends Cloud {
      // this is just a convenience thing
      constructor(x, y, z) {
        super({pos_x:x, pos_y:y, pos_z:z})
      }
    }
    class Floor extends Plane {
      // this is just a convenience thing
      constructor(x, y, z) {
        super({pos_x:x, pos_y:y, pos_z:z})
      }
    }
    // floor
    for (let i = -10; i <= 10; i++) {
      // for (let j = -10; j <= 10; j++) {
        for (let k = -10; k <= 10; k++) {
          new Floor(i, 0, k)
        }
      // }
    }
    // rain wall
    for (let i = -4; i <= 4; i++) {
      for (let j = 1; j <= 8; j++) {
        // for (let k = -10; k <= 10; k++) {
          new Marker(
              i + Math.random()-0.5,
              j + Math.random()-0.5,
              -10 + Math.random()-0.5,
          )
        // }
      }
    }
    // clouds
    for (let i = -4.5; i <= 4.5; i+=0.5) {
      // for (let j = 1; j <= 8; j++) {
        // for (let k = -10; k <= 10; k++) {
          new CloudWithPosThing(
              i + Math.random()-0.5,
              YROOF + Math.random()-0.5,
              -10 + Math.random()-0.5,
          )
        // }
      // }
    }
  }

  class Robot {
    constructor() {
      this.history = new Array(0);
      this.grabbed = null;
      this.anchor = document.createElement('a')
      this.input = document.createElement('input')
      this.input.setAttribute('type', 'file')
      this.input.setAttribute('multiple', '')

      this.input.addEventListener('input', files => this.parseFiles());

      this.sceneEntities = new Array(0);
      this.filesAsJSON = new Array(0);

      this.target = {
        x: 0,
        y: 1,
        z:-2
      }

      window.addEventListener('DOMContentLoaded', e => {
        document.body.append(this.anchor)
        document.body.append(this.input)
        this.sceneEl = document.querySelector('a-scene')
        document.querySelector('body').ondragover = e => {
          e.preventDefault();
        };
        document.querySelector('body').ondrop = e => {
          console.log(e)
          e.preventDefault();
          if (e.dataTransfer.items) {
            // Use DataTransferItemList interface to access the file(s)
            console.log('marco')
            for (var i = 0; i < e.dataTransfer.items.length; i++) {
              // If dropped items aren't files, reject them
              if (e.dataTransfer.items[i].kind === 'file') {
                var file = e.dataTransfer.items[i].getAsFile();
                this.parseDroppedFile(file)
                // console.log('... file[' + i + '].name = ' + file.name);
              }
            }
          } else {
            // Use DataTransfer interface to access the file(s)
            console.log('polo')
            // for (var i = 0; i < e.dataTransfer.files.length; i++) {
            //   console.log('... file[' + i + '].name = ' + e.dataTransfer.files[i].name);
            // }
          }
        };
      });
      document.addEventListener('ybuttondown', e => {
        this.askUserForFiles();
      });
      document.addEventListener('xbuttondown', e => {
        this.rumFromParsedFiles('test');
      });

      this.dinger = document.createElement('audio')
      this.dinger.src = '../../sine-432hz-pluck.flac';

    };
    askForFiles() {
      this.input.click();
    }
    parseDroppedFile(file) {
      if(file.type.includes('image/')) {
        let reader = new FileReader();
        reader.onload = (e) => {
          let parsedFile = {
            dataURL: reader.result,
            position: `${this.target.x++} ${this.target.y} ${this.target.z}`,
          }
          this.rumBlobToEntity(parsedFile);
        }
        reader.readAsDataURL(file); 
      }
    }
    parseFiles() {
      this.parsedFiles = new Array(this.input.files.length)
      let files = this.input.files;
      if(files.length === 1 && files[0].name.includes('.rum')) {
        this.parseRum(files[0]);
      } else {
        for(let i = 0; i < this.input.files.length; i++) {
          let file = this.input.files[i];
          if(file.type.includes('image/')) {
            let reader = new FileReader();
            let idx = i;
            reader.onload = (e) => {
              let parsedFile = this.parsedFiles[idx] = {
                dataURL: reader.result,
                position: `${i} 1 -2`,
              }
              this.rumBlobToEntity(parsedFile);
            }
            reader.readAsDataURL(file); 
          }
        }
      }
    };
    parseRum(rumFile) {
      if(rumFile.name.includes('.rum')) {
        let reader = new FileReader();
        reader.onload = (e) => {
          this.parsedFiles = JSON.parse(reader.result);
          this.renderParsedFiles();
        }
        reader.readAsText(rumFile); 
      }
    };
    rumFromParsedFiles(name) {
      let file = new File([JSON.stringify(this.parsedFiles)], `${name}.rum`);
      this.downloadFile(file)
    };
    downloadFile(file) {
      let a = URL.createObjectURL(file)//<-- REMEMBER TO GARBAGE COLLECT THIS ???
      this.anchor.href = a;
      this.anchor.download = file.name
      this.anchor.click()
    };
    rumToParsedFiles(rumFile) {
      // load a .rum file onto parsedFiles 
      let file = rumFile;

      let reader = new FileReader();
      reader.onload = (e) => {
        this.parsedFiles = JSON.parse(reader.result)
      }
      reader.readAsDataURL(file); 
    };
    say(wut) {
      let timestamp = Date.now();
      console.log(wut);
      this.history.push({
        timestamp: timestamp,
        action: "say",
        params: wut,
      })
    };
    grab(wut) {
      return this.grabbed = document.querySelector(wut) || null;
    };
    z(a) {
      window.console.log('console logging')
    };
    renderParsedFiles() {
      for(let i = 0; i < this.parsedFiles.length; i++) {
        this.rumBlobToEntity(this.parsedFiles[i]);
      }
    }
    rumBlobToEntity(rumBlob) {
      let entity = document.createElement('a-image')
      entity.setAttribute('src', rumBlob.dataURL)
      entity.setAttribute('position', rumBlob.position)
      this.sceneEntities.push(entity)
      document.querySelector('a-scene').appendChild(entity)
    };
    fromBase64() {

    };
    toBase64() {

    };
    saveRum(name) {


    };
    // renderInputFiles
    // https://stackoverflow.com/questions/7951326/save-image-to-users-disk-using-javascript
    toGLTF(wut) {
      // TODO: REMOVE THIS, and remove the exporter js file
      // https://threejs.org/docs/#examples/en/exporters/GLTFExporter
      // Instantiate a exporter (worth instantiating on each export?)
      var exporter = new THREE.GLTFExporter();
      var options = undefined

      let callback = thing => window.z = thing
      // Parse the input and generate the glTF output
      exporter.parse( wut, callback, options );
      // exporter.parse( wut, function ( gltf ) {
      //   console.log( gltf );
      //   console.log('parse that thins!')
      //   downloadJSON( gltf );
      // }, options );
    };
    replay() {
      var offset = undefined;
      if(this.history.length > 0) {
        offset = Date.now() - this.history[0].timestamp;
      }
      while(this.history.length > 0) {
        let action = this.history.shift();
        let now = Date.now();
        let when = now - action.timestamp;
        setTimeout(() => { this[action.action](action.params); }, when - offset);
      }
    };
    ding() {
      if (this.dinger.paused) {
        this.dinger.play();
      } else {
        this.dinger.currentTime = 0;
      }
    }
  }
  window.bot = new Robot()
  }</script>

</html>
